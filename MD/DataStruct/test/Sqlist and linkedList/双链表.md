# 双链表

双链表顾名思义，就是链表由单向的链变成了双向链。 使用这种数据结构，我们可以不再拘束于单链表的单向创建于遍历等操作，大大减少了在使用中存在的问题。
解决链表问题的关键在于画图

## 结构

在双链表中，结构体拥有两个域：前指针域和后指针域。分别指向前后结点。

```c
typedef struct List{
int data;// 数据域
struct List *next;//  向后的指针
struct List *front;//  向前的指针
};

```

## 常见用法

### CreatList

```c
    pElem CreatList(){
        pElem head = (pElem)malloc( sizeof(eElem) );
        assert( head != NULL );//  包含于标准库<assert.h>
        head->next = head->front = NULL;//  初始化链表，指针置空
        return head;
        pElem tmpHead = head;  //  创建一个临时的头结点指针
        if( tmpHead->next == NULL ){
            /*  当双向链表只有一个头结点时 */  
            pElem addition = (pElem)malloc( sizeof(eElem) );
            assert( addition != NULL );
            addition->data = data;  //  数据域赋值
            addition->next = tmpHead->next;  //  后向指针连接
            tmpHead->next = addition;
            addition->front = tmpHead;   //  将插入结点的front 指向头结点
    }
    else{
        /* 当双向链表不只一个头结点时 */
        pElem addition = (pElem)malloc( sizeof(eElem) );
        assert( addition != NULL );
        addition->data = data;  //  数据域赋值
        tmpHead->next->front = addition;  //  头结点的下一个结点的front 指针
        addition->front = tmpHead;  //  插入的结点的front 指针指向头结点
        addition->next = tmpHead->next;  //  插入结点的next 指针指向原本头指针的下一结点
        tmpHead->next = addtion;  //  将头结点的next 指针指向插入结点
    }
    }

}
```

这里就比较难以理解了，双向链表的创建需要同时注意两个位置。

