# 二叉树

在这里补充一点，函数指针和指针函数，**指针函数**是指返回值是指针的函数，即本质是一个函数。我们知道函数都有返回类型（如果不返回值，则为无值型），只不过指针函数返回类型是某一类型的指针。
**函数指针**指向某种特定类型，函数的类型由其参数及返回类型共同决定，与函数名无关。

[toc]

## 树

树形数据结构是一种重要的非线性结构。Tree为n个节点的有限集，它有着以下特点：

- 1.有且仅有一个根(Root)节点

- 2.每个集合本身就是一棵树，并相对于根为**子树**

并且他还有以下常见术语：

- 1.节点拥有的子树数称为**度**，度为0的节点被称为终端节点，其它被称为分支节点

- 2.节点的子树称为孩子(Child)节点，孩子称节点为双亲(Parent)

- 3.节点层次从根的开始开始定义，根为1，树中最大的层次称为**深度**

- 4.如果树中的各子树无序（即不能互换）可称该树为无序树。

- 5.森林是m(m>=0)颗互不相交的树的集合。

且具有以下几种性质：

- 树中的所有节点数加一等于总结点数：n = 1 + n1 + 2*n2 +··

- 各节点数之和为总结点数：n = n0 + n1 + n2 + ···

- **并且有如下常考性质**：

    > 度为m的树：一定非空，且至少有一个度为m的结点
    m叉树：可空，允许所有结点都<m
    高为h，的m叉树结点树：简单的等比数列求和即可

## *二叉树*

二叉树是每个节点至多只能有两个节点，并且**有**左右之分(二叉树可以为空)，除此之外，根结点没有双亲结点。由于二叉树的结构特性，我们就可以利用它结构简单的特点进行功能设计

其具有以下的特点（只有熟练地运用这些性质，才能较为顺畅地进行程序设计）：

- 1.在二叉树的第i层上至多有$2^{i-1}$个结点，深度为k的二叉树最多有$2^k-1$个结点

- 2.对于任何一颗二叉树，如果其终端节点为$n_0$，度为2的结点为$n_2$,则$n_0$=$n_2$+1

- 3.几个特殊的二叉树：

    1. 满二叉树：高为h，且节点数为$2^h-1$，即每层都有最大的节点数
        > 按照从一开始编序，结点i的左孩子为2i，右孩子为2i+1，同样的左孩子的双亲结点为i/2
    2. 完全二叉树：点与完全二叉树对应，且可以去掉较大的结点。**性质**：具有n个结点的二叉树高度介于$\log_2(n+1)$ 与 $\log_2{n}+1$ 之间
        >性质与上类似，且最多只有一个度为1的点。按层序编号，当i<=i/2
        ![202202051559002022-02-05](https://s2.loli.net/2022/02/05/rwpA9e7jyJF3MmR.png)
    3. 二叉排序树：左树上所有结点均小于根结点，右边结点均大于根

    4. 平衡二叉树：任何一颗子树的左右之深度之差小于1

一些王道上的考题：

![202202061525322022-02-06](https://s2.loli.net/2022/02/06/4gVbP1FqLj5lIJB.png)这里非空指针数=总分支数=n-1 ,空指针数= 2n-非空

更多的题目，只需要牢记树、二叉树的性质即可

### 实践1——二叉树的定义

根据上面的定义，我们大致可以设计出二叉树的结构：

```c
typedef struct 
{
    //定义树节点的结构体
    int data;
    BiTree * LChlid;    //代表左子节点
    BiTree * RChlid;    //代表右子节点
}BiTNode, * BiTree;
```

在这里，我们需注意为什么要使用* BiTree，这时为了方便我们以后的操作。

### 二叉树的遍历

二叉树的结构特点，决定了它有着多种的遍历方式，这种特性，也决定了很难通过一种遍历方式就完全还原一各二叉树

![202202061629172022-02-06](https://s2.loli.net/2022/02/06/cTW3MYN6hAZ2nmJ.png),一个例题，先写出大框架，之后再完善子树部分

#### 先序遍历

根左右
性质：
1.根节点在首位

#### 中序遍历

左根右

#### 后序遍历

左右根
性质：
1.根结点在末尾

#### 层次遍历

从上到下，自左到右。但在这里，不能简单的使用函数完成。需要借助链式队列的帮助：
算法思路：

1. 初始化一个辅助队列

2. 将根节点入队

3. 当非空时，队头出队，访问该节点，将左右孩子结点添加至队尾

4. 重复3，直至队列为空

#### 由二叉树的遍历序列确定二叉树（即给定一串字符，让你确定二叉树）

二叉树的先序和中序序列（中序和后序，层序和中序）可以唯一的确定一颗二叉树（都需要两种方式才能确定）。

一般的我们先找出根节点在哪，之后再比对得出二叉树

前+中：通过先序找根结点，然后通过中序划分左右，再根据各自特点找子树。找子树的过程中，先序的遍历都是优先根结点的
![202202071556592022-02-07](https://s2.loli.net/2022/02/07/XiK9esMrdJz6TGL.png)

后+中：先通过后序找根，之后步骤与上面一致。找子树也是相同，后序离根近的也是子树的根节点
![202202071558002022-02-07](https://s2.loli.net/2022/02/07/Rue9QJNPFz758rl.png)

层+中：先通过层序找根，之后再找子树。
![202202071559222022-02-07](https://s2.loli.net/2022/02/07/PCykd3gzfOXA5K6.png)

### 实践2-二叉树的构建和遍历

#### 构建与遍历本质上是一致的，故要使用递归和非递归两种方式实现

#### 层次遍历单独拿出来编写

### 线索二叉树

将二叉树中的空链域用来存储前驱后继结点信息。按照遍历的顺序，以及空链域来编线索二叉树。没有孩子，则指向祖先结点
![202202071653182022-02-07](https://s2.loli.net/2022/02/07/ISFVc5al9LTOUkY.png)

存储结构：
> 在普通二叉树的基础上，设置两个标志位，ltag和rtag,当tag==1，表示指向前驱，当tag==0时，表示指向对应的孩子

当我们将一个二叉树线索化之后，就可以方便的寻找前驱和后继

### 二叉排序树

BST，又称二叉查找树。特点：左子树上的点小于根节点，右子树上的点大于根节点，于是我们就可以使用中序遍历得到一颗递增的有序序列。

### 实践：维护一颗二叉排序树，并实现部分功能

1. 插入

    ![202202160001572022-02-16](https://s2.loli.net/2022/02/16/KrxUm3z2nMZs4DJ.png)

2. 查找

    ![202202160002452022-02-16](https://s2.loli.net/2022/02/16/4hVc9ZNJwYAOELr.png)

3. 构造

    按特性进行创建

4. 删除

    分三种情况：

    - 被删除的结点没有孩子结点：直接删

    - 被删除的结点只有一个孩子结点，直接用孩子结点替换

    - 被删除的结点有两个孩子结点：选取右孩子树中最小的结点

5. 平均查找长度的效率分析

    即分析查找指针停留的位置，依次来估计查找次数
    ![202202160015512022-02-16](https://s2.loli.net/2022/02/16/8FkeUobyPMszhEc.png)

### 平横二叉树

AVL树上任意一个左子树和右子树的深度之差不超过1（就可以保证查找效率到$log_2n$），其核心就是在插入或者删除的时候，进行调整以保证平衡

![202202160018462022-02-16](https://s2.loli.net/2022/02/16/4uZ6KUB7JyfDXim.png)

从图中可以知道，不平衡点从之差大于1作为根节点找得。之后最关键的就是调整最小不平衡子树

分为四种情况，两种基本操作：左旋和右旋

- LL：左孩子左子树导致不平衡

    ![202202171653282022-02-17](https://s2.loli.net/2022/02/17/pRfcaMsAyFvWn5P.png)将根拽下放到左孩子的右节点上，再将原先结点指向根

- RR：右孩子右子树导致不平衡

    将根拽到右孩子的左节点，再将原先右孩子的左节点指向旧根
    ![202202171734312022-02-17](https://s2.loli.net/2022/02/17/7fFkq4Kn32thgcP.png)
- LR：左孩子右子树
    先左旋后右旋
    ![![202202171736262022-02-17](httpss2.loli.net20220217ok1pyUYEA26fHZi](https://s2.loli.net/2022/02/17/hrma5f89kyA6jKP.png)

### 哈夫曼树

n个结点的带权路径长度最小，也称最优二叉树

#### 1.哈夫曼树的构造

![202202172051492022-02-17](https://s2.loli.net/2022/02/17/TI3iY94HQo5jshv.png)即先让权小的合并

特性：

- 1.哈夫曼树只有0和2的结点

- 2.可以等长也可以不等
    ![202202182027072022-02-18](https://s2.loli.net/2022/02/18/MFd2kqIZQozNRrJ.png)使用哈夫曼编码旧必须要让结点为叶子.

- 3.要构造含n个字符结点的哈夫曼树，需新建n-1结点，共2n-1

- 4.前缀编码，若没有一个编码为另一个字符的前缀,或者说，构建一颗二叉树创建的都是新结点（没有重复）